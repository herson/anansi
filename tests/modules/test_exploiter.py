import unittest
from unittest.mock import patch, mock_open
import subprocess
import yaml
from modules.exploiter import Exploiter

class TestExploiter(unittest.TestCase):

    @patch('builtins.open', new_callable=mock_open, read_data='default:\n  metasploit_enabled: true')
    def test_init(self, mock_file):
        vulnerabilities = {8080: {'service': 'http'}}
        exploiter = Exploiter(vulnerabilities)
        self.assertEqual(exploiter.vulnerabilities, vulnerabilities)
        self.assertTrue(exploiter.config['default']['metasploit_enabled'])
        mock_file.assert_called_once_with('config.yaml', 'r')

    @patch('subprocess.run')
    @patch('builtins.open', new_callable=mock_open, read_data='default:\n  metasploit_enabled: true')
    def test_exploit_success(self, mock_file, mock_subprocess):
        vulnerabilities = {8080: {'service': 'http'}}
        exploiter = Exploiter(vulnerabilities)
        exploiter.exploit()
        mock_subprocess.assert_called_once()  # Ensure subprocess.run was called

    @patch('subprocess.run', side_effect=subprocess.CalledProcessError(1, 'cmd'))
    @patch('builtins.open', new_callable=mock_open, read_data='default:\n  metasploit_enabled: true')
    @patch('logging.error')
    def test_exploit_failure(self, mock_logging, mock_file, mock_subprocess):
        vulnerabilities = {8080: {'service': 'http'}}
        exploiter = Exploiter(vulnerabilities)
        exploiter.exploit()
        mock_logging.assert_called_once_with("Failed to exploit service on port %s: %s", 8080, mock_subprocess.side_effect)

if __name__ == '__main__':
    unittest.main()
